# [264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

编写一个程序，找出第 `n` 个丑数。

丑数就是质因数只包含 `2, 3, 5` 的**正整数**。

**示例:**

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**说明:** 

1. `1` 是丑数。
2. `n` **不超过**1690。

***

## CPP

```cpp
/*
【笔记】三指针法。一部分是丑数数组，另一部分是权重2，3，5。下一个丑数，定义为丑数数组中的数乘以权重，所得的最小值。

那么，2该乘以谁？3该乘以谁？5该乘以谁？

其一，使用三个指针idx[3]，告诉它们。比如，2应该乘以ugly[idx[0]]，即数组中的第idx[0]个值。（权重2，3，5分别对应指针，idx[0],idx[1],idx[2]）

其二，当命中下一个丑数时，说明该指针指向的丑数 乘以对应权重所得积最小。此时，指针应该指向下一个丑数。（idx[]中保存的是丑数要乘的权重）

其三，要使用三个并列的if让指针指向一个更大的数，不能用if-else。因为有这种情况：

丑数6，可能由于丑数2乘以权重3产生；也可能由于丑数3乘以权重2产生。

丑数10，... 等等。

执行用时：16 ms, 在所有 C++ 提交中击败了62.91%的用户
内存消耗：7.6 MB, 在所有 C++ 提交中击败了47.55%的用户
*/
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> ugly(n, 1), idx(3, 0);
        for(int i = 1; i < n; ++i){
            int a = ugly[idx[0]] * 2, b = ugly[idx[1]] * 3, c = ugly[idx[2]] * 5;
            int next = std::min(a, std::min(b, c));
            if(a == next) ++idx[0];
            if(b == next) ++idx[1];
            if(c == next) ++idx[2];
            ugly[i] = next;
        }
        return ugly.back();
    }
};
```

