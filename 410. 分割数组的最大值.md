# 410. 分割数组的最大值

给定一个非负整数数组和一个整数 *m*，你需要将这个数组分成 *m* 个非空的连续子数组。设计一个算法使得这 *m* 个子数组各自和的最大值最小。

**注意:**
数组长度 *n* 满足以下条件:

- 1 ≤ *n* ≤ 1000
- 1 ≤ *m* ≤ min(50, *n*)

**示例:**

```
输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
```



***

## CPP

方法三 二分搜索 + 贪心 【通过】
思路

我们很容易就能找到这个答案的一个性质：

如果我们找到了一种分割方案，使得最大的分割子数组和不超过 x，那么我们也能找到一种分割方案使得最大的分割子数组和不超过 y，其中 y 大于 x。

对于值 x，我们把这个性质定义为 F(x)。如果 F(x) 为真，那就意味着我们一定可以找到一种分割方案使得最大的分割子数组和不超过 x。

我们让 x 的区间为 负无穷大 到 无穷大，一旦我们找到一个值 x0，使得所有的 x < x0，F(x) 都为假，所有的 x >= x0，F(x) 都为真。那么显然，这个 x0 就是我们要的答案了。

算法

我们可以用二分搜索来找到 x0。每次循环，我们让 mid = (left + right) / 2，如果 F(mid) 为假，那么我们接下来就去搜索 [mid + 1, right] 区间；如果 F(mid) 为真，那么我们接下来就去搜索 [left, mid - 1] 区间。

对于一个给定的 x，我们可以用贪心算法来计算 F(x)。我们用累计和 sum 来记录当前子数组的和，同时用 cnt 来记录子数组的数量。我们依次处理数组中的每个元素，对每个元素 num，如果 sum + num <= x，这就意味着当前的子数组没有超过限制。否则，就需要从当前元素 num 开始分割出一个新的子数组。

在完成遍历完整个数组之后，比较 cnt 和 m 的值。如果 cnt <= m，这就意味可以找到一种分割方案使得最大的分割子数组和不超过 x。否则，F(x) 一定为假。

```cpp
#define LL long long
class Solution {
public:
    int splitArray(vector<int>& nums, int m) {
        LL l = 0, r = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            r += nums[i];
            if (l < nums[i]) {
                l = nums[i];
            }
        }
        LL ans =  r;
        while (l <= r) {
            LL mid = (l + r) >> 1;
            LL sum = 0;
            int cnt = 1;            
            for (int i = 0; i < n; i++) {
                if (sum + nums[i] > mid) {
                    cnt ++;
                    sum = nums[i];
                } else {
                    sum += nums[i];
                }
            }
            if (cnt <= m) {
                ans = min(ans, mid);
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        return ans;
    }
};
/*
复杂度分析
时间复杂度： O(n∗log(sum of array))
二分搜索的时间复杂度为 O(log(sum of array))，其中 sum of array 是 nums 中所有元素之和。每次计算 F(x)，时间复杂度为 O(n)
空间复杂度： O(1)
*/
```

