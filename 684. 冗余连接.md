# [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

在本问题中, 树指的是一个连通且无环的**无向**图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。

**示例 1：**

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
```

**示例 2：**

```
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3
```

**注意:**

- 输入的二维数组大小在 3 到 1000。
- 二维数组中的整数在1到N之间，其中N是输入数组的大小。

**更新(2017-09-26):**
我们已经重新检查了问题描述及测试用例，明确图是***无向*** 图。对于有向图详见**[冗余连接II](https://leetcodechina.com/problems/redundant-connection-ii/description/)。**对于造成任何不便，我们深感歉意。

***

## CPP



官方题解把并查集的原理和用法讲得很明白了
但是在具体实现上没有说。
我这里简单说一下吧，希望能帮助对并查集不熟的小伙伴快速上手

具体落实到这个题上，通俗讲解一下

先明确几个概念
1.集合树：所有节点以代表节点为父节点构成的多叉树
2.节点的代表节点：可以理解为节点的父节点，从当前节点出发，可以向上找到的第一个节点
3.集合的代表节点：可以理解为根节点，意味着该集合内所有节点向上走，最终都能到达的节点
来个图帮助理解

<img src="https://pic.leetcode-cn.com/a01e4fa1fbb1513961b81ff3ea983a028b3c120a39d202527e7c9278e88cffa5-image.png" alt="image.png" style="zoom: 80%;" />


上图中是一棵集合树，树中有1-6总计6个节点
整个集合的代表节点是1
4节点的代表节点是3，6节点的代表节点是1
无论沿着哪个节点向上走，最终都会达到集合代表节点的1节点

然后具体到这个题上：
我们以这个边集合为例子[[1,2], [3,4], [3,2], [1,4], [1,5]]

一、首先，对于边集合edges的每个元素，我们将其看作两个节点集合
比如边[2, 3],我们将其看作节点集合2，和节点集合3

二、在没有添加边的时候，各个节点集合独立，我们需要初始化各个节点集合的代表节点为其自身
所以，我们先初始化一个容器vector，使得vector[i]=i
这里两个i意思不同，作为索引的i是指当前节点，作为值的i是指当前节点所在集合的代表节点
比如vector[2] = 2，意味着2这个节点所在集合的代表节点就是2，没有添加边的情况下，所有节点单独成集合，自身就是代表节点
初始化后，集合图如下图所示：

<img src="https://pic.leetcode-cn.com/df3fcfb47ac68f45aaf3d80834e8044a91e6a42e63baa60be521839083338f9b-image.png" alt="image.png" style="zoom:80%;" />

三、然后我们开始遍历边集合，将边转化为集合的关系
这里有一点很重要：边[a,b]意味着a所在集合可以和b所在集合合并。
合并方法很多，这里我们简单地将a集合的代表节点戳到b集合的代表节点上
这意味着，将b集合代表节点作为合并后大集合的代表节点
对于一个集合的代表节点s，一定有s->s，意思是s如果是代表节点，那么它本身不存在代表节点
假设我们的读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
初始化vector[0, 1, 2, 3, 4, 5]
对应的index [0, 1, 2, 3, 4, 5]
##########################################################################

1.读取[1,2]：
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
当前vector[0, 1, 2, 3, 4, 5]
当前index [0, 1, 2, 3, 4, 5]
原本1->1，2->2，
由1节点出发，vector[1]=1, 找到1所在集合的代表节点1
由2节点出发，vector[2]=2, 找到2所在集合的代表节点2
于是，将1的代表置为2，vector[1]=2, vector[2]=2
对应的vector[0, 2, 2, 3, 4, 5]
对应的index [0, 1, 2, 3, 4, 5]
原集合变为下图：

<img src="https://pic.leetcode-cn.com/c95f25c4df2dce2f872fdc076bc0c8168c3ad241b8bd18638da68112e013c908-image.png" alt="image.png" style="zoom:80%;" />


##########################################################################

2.读取[3, 4]
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
当前vector[0, 2, 2, 3, 4, 5]
当前index [0, 1, 2, 3, 4, 5]
同理，将3所在集合的的代表节点3的代表节点置为4
对应的vector[0, 2, 2, 4, 4, 5]
对应的index [0, 1, 2, 3, 4, 5]
集合变化如下图：

<img src="https://pic.leetcode-cn.com/52d1a28110784aee9b145cd725834a51a4e9e7e87e5ec5a2ba2c83f42c44dc79-image.png" alt="image.png" style="zoom:80%;" />


##########################################################################

3.读取[3, 2]
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
当前vector[0, 2, 2, 4, 4, 5]
当前index [0, 1, 2, 3, 4, 5]
从节点3出发，vector[3]=4, vector[4]=4,于是找到节点3所在集合的代表节点为4
从节点2出发，vector[2]=2, 找到节点2所在集合的代表节点为2
于是，将4的代表置为2，vector[4]=2, vector[2]=2
对应的vector[0, 2, 2, 4, 2, 5]
对应的index [0, 1, 2, 3, 4, 5]
集合变化如下图：

<img src="https://pic.leetcode-cn.com/0df9d3c5f9647b040b001c42c2e946975ddcc282f0c805d85e3addb126f7b695-image.png" alt="image.png" style="zoom:80%;" />


##########################################################################

4.读取[1, 4]
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
当前vector[0, 2, 2, 4, 2, 5]
当前index [0, 1, 2, 3, 4, 5]
从节点1出发，vector[1]=2, vector[2]=2, 找到节点1所在集合代表节点为2
从节点4出发，vector[4]=2, vector[2]=2, 找到节点4所在集合代表节点为2
由于1和4的代表节点相同，说明这两个节点本身就在同一个集合中
由于原图是无向图，路径是双向可达的，1能够到达2,而且2能够到达4，再加上1能够到达4
说明1能通过两条路径到达4，,这也意味着这条边出现的时候，原图中一定出现了环
至于题中要求的，返回最后一条边，其实这就是返回添加过后会构成环的那一条边
直白解释就是，在这条边出现之前，图中没有环
这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边
然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边

```cpp
/*
执行用时: 16 ms
内存消耗: 8.4 MB
*/
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        vector<int> rp(1001);
        int sz = edges.size();
        // 初始化各元素为单独的集合，代表节点就是其本身
        for(int i=0;i<sz;i++)
            rp[i] = i;
        for(int j=0;j<sz;j++){
            // 找到边上两个节点所在集合的代表节点
            int set1 = find(edges[j][0], rp);
            int set2 = find(edges[j][1], rp);
            if(set1 == set2)  // 两个集合代表节点相同，说明出现环，返回答案
                return edges[j]; 
            else    // 两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上
                rp[set1] = set2;
        }
        return {0, 0};
    }

    // 查找路径并返回代表节点，实际上就是给定当前节点，返回该节点所在集合的代表节点
    // 之前这里写的压缩路径，引起歧义，因为结果没更新到vector里，所以这里改成路径查找比较合适
    // 感谢各位老哥的提议
    int find(int n, vector<int> &rp){
        int num = n;
        while(rp[num] != num)
            num = rp[num];
        return num;
    }
};
```



```cpp
//执行用时为 4 ms 的范例

class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        vector<int> rp(1001);//存放代表节点
        int len = edges.size();
        for(int i = 0; i < len; i++){ //初始化代表接口节点
            rp[i] = i; 
        }
        for(int j = 0; j < len; j++){
            //找到边的两个点所在集合的代表节点
            int set1 = find(edges[j][0], rp);//edge中存放输入的边，为N行两列的数组，每一行存放的边的两个点
            int set2 = find(edges[j][1], rp);
            if(set1 == set2)//两个集合代表节点相等，说明出现环，返回边
                 return edges[j];
            else
                rp[set1] = set2;//两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上
				//rp[set2] = set1; 运行时间减少4ms
        }
        return {0,0};
    }
    //给定当前节点，返回该节点所在集合的代表尽快节点
    int find(int n,vector<int> &rp){
        while(rp[n] != n) //此处必须用while:执行语句运行完毕，自动返回继续判断while中的条件是否符合，符合的话，继续运行执行语句，不符合，则退出循环。
            n = rp[n];
        return n;
    }
};
```

